<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue3组合式Api</title>
      <link href="/2023/05/24/04vue3/"/>
      <url>/2023/05/24/04vue3/</url>
      
        <content type="html"><![CDATA[<h2 id="组合式Api"><a href="#组合式Api" class="headerlink" title="组合式Api"></a>组合式Api</h2><blockquote><p>组合式api,用于返回数据,取代data(){}以及methods{},</p><p>组合式api中没有this这个属性</p></blockquote><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><blockquote><p>定义方法和变量</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setup() &#123;</span><br><span class="line">  const log = () =&gt; console.log(&#x27;hello world&#x27;)</span><br><span class="line">  return &#123;</span><br><span class="line">    log</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h4><blockquote><p>变量包装为<strong>响应式数据</strong>,能引起视图的更新</p><p>否则,变量更新不会引起页面的更新</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setup() &#123;</span><br><span class="line">  let a = ref(100)</span><br><span class="line">  const user = reactive(&#123; name: &#x27;zs&#x27;, age: 100 &#125;)</span><br><span class="line">  const log = () =&gt; console.log(&#x27;hello world&#x27;)</span><br><span class="line">  return &#123;</span><br><span class="line">    log,</span><br><span class="line">    a,</span><br><span class="line">    user</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>ref()</code>用于简单数据类型,也可以用于复杂类型,会使用reactive()让对象成为响应式数据.但是使用时,需要object.value,非常的麻烦,所以简单数据类型使用 ref(),复杂使用reactive()</p></li><li><p><code>reactive()</code>用于复杂类型，例如对象或数组,是<strong>深层次</strong>的响应。</p></li></ol><p><strong>总之:</strong><code>ref()</code>主要用于单个值的响应式管理，而<code>reactive()</code>主要用于对象和数组的响应式管理。</p><h4 id="shallowReactive-shalloRef"><a href="#shallowReactive-shalloRef" class="headerlink" title="shallowReactive || shalloRef"></a>shallowReactive || shalloRef</h4><blockquote><p>只让第一层属性成为响应式,深层对象不会为响应式</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230523213247.png" alt="image-20230523213247015"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>关于ref(),reactive()是为了自定义响应式数据,使用时更加的便捷.</p><p>对于ref()相当于java的包装类,在脚本区域(<script>)使用,需要<strong>object.value</strong>对值修改</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let num=ref(100)</span><br><span class="line">const user=ref(&#123;name:&#x27;zs&#x27;,age:11&#125;)</span><br><span class="line">......</span><br><span class="line">num.value=114</span><br><span class="line">user.value.age=514</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230523153125.png" alt="image-20230523153118409"></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230523164816.png" alt="image-20230523164816799"></p><h3 id="setup-两个形参"><a href="#setup-两个形参" class="headerlink" title="setup()两个形参"></a>setup()两个形参</h3><blockquote><p>setup可以接收两个形参(<strong>props</strong>,<strong>context</strong>)</p></blockquote><h4 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h4><blockquote><p>需要声明props属性,然后方法才能接收</p></blockquote><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><ol><li>首先在对象中定义props</li><li>setup函数的第一个参数就为props的代理对象</li></ol><h4 id="context"><a href="#context" class="headerlink" title="context"></a>context</h4><blockquote><p>上下文对象</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230523191408.png" alt="image-20230523191408596"></p><ul><li>attrs:未在props中声明的属性会在这里,相当于this.$attrs</li><li>slots:收到的插槽内容,相当this.$slots</li><li>emit:分发自定义事件的函数,相当于this.$emit</li></ul><h3 id="Computed计算属性"><a href="#Computed计算属性" class="headerlink" title="Computed计算属性"></a>Computed计算属性</h3><blockquote><p>在setup中简写</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const com = computed(() =&gt; a.value + &#x27;xxx&#x27;)</span><br></pre></td></tr></table></figure><ol><li>从vue中导入compute函数</li><li>定义变量,并使用compute函数</li><li>return中返回数据</li></ol><h3 id="Watch监听器"><a href="#Watch监听器" class="headerlink" title="Watch监听器"></a>Watch监听器</h3><blockquote><p>监听数据变化 </p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    watch(a, () =&gt; &#123;</span><br><span class="line">      console.log(&#x27;发生变化&#x27; + a.value)</span><br><span class="line">    &#125;)</span><br><span class="line">-------</span><br><span class="line">    watch(a, &#123;</span><br><span class="line">handler(newval,oldval)&#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;,</span><br><span class="line">immediate:true,</span><br><span class="line">deep:true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>从vue中导入函数</li><li>使用watch方法,第一个参数为变量名,第二个为对应的回调函数,第三个为相关配置</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watch(a, () =&gt; &#123;</span><br><span class="line">   console.log(&#x27;发生变化&#x27; + a.value)</span><br><span class="line">&#125;,&#123;deep:true,immediate:true&#125;)</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol><li>第一个参数监听的属性多个<strong>可以定义多个</strong>;也可<strong>写成数组模式</strong>,对应的<strong>newVal,oldVal也为数组</strong></li><li>第二个参数为相关逻辑处理函数</li><li>第三个是配置对象</li><li>监听reactive对象的某个属性,第一个参数使用函数返回 <code>()=&gt; user.name</code></li><li>监听多个属性,直接数组嵌套方法<code>[()=&gt;user.name,()=&gt;user.age]</code></li><li>对于deep属性,如果监听的为对象中的属性,建议开启deep</li></ol><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230523195042.png" alt="image-20230523195042082"></p><h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><blockquote><p>watch的强化版,只监听函数中使用到的数据</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watchEffect(() =&gt; &#123;</span><br><span class="line">   const count = a.value</span><br><span class="line">   console.log(&#x27;watchEffect起作用~~&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>无需指定监听的数据</li><li>只有一个参数,为回调函数</li></ol><h3 id="setup嵌套声明函数"><a href="#setup嵌套声明函数" class="headerlink" title="setup嵌套声明函数"></a>setup嵌套声明函数</h3><blockquote><p>在setup中定义声明周期函数</p></blockquote><ul><li>对于create,beforecreated函数,setup中没有对应的函数</li><li>对于beforeMount,mounted==&gt;onBeforeMount,onMounted</li><li>对于beforeUpdate,updated==&gt;onBeoforeUpdate,onUpdated</li><li>对于beforeUnmounte,Unmounted==&gt;onBeforeUnmounte,onUnmounted<br><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230523205120.png" alt="image-20230523205120812"></li></ul><h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><blockquote><p>抽取相关方法放入指定模块,调用时直接导入并使用</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230523210127.png" alt="image-20230523210127637"></p><h3 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h3><blockquote><p>动态绑定变量与响应式对象中的属性,简化使用</p><p>在使用时,—&gt;</p></blockquote><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p><code>const username=toRef(对象,属性)</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//如果想返回响应式对象的属性</span><br><span class="line">setup()&#123;</span><br><span class="line">let user=reactive(&#123;name:&#x27;zs&#x27;&#125;)</span><br><span class="line">return&#123;</span><br><span class="line">username:user.name</span><br><span class="line">//相当于username:&#x27;zs&#x27;,当user数据动态响应时,username的值并不会改变</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">======</span><br><span class="line">setup()&#123;</span><br><span class="line">let user=reactive(&#123;name:&#x27;zs&#x27;&#125;)</span><br><span class="line">return&#123;</span><br><span class="line">username:toRef(user,&#x27;name&#x27;)</span><br><span class="line">//相当于建立了桥梁,user.name更改,username更改(类似变量的地址引用)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h3><blockquote><p>用于简化reactive对象的使用,一次获取对象</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setup()&#123;</span><br><span class="line">let user=reactive(&#123;name:&#x27;zs&#x27;,age:100&#125;)</span><br><span class="line">return&#123;</span><br><span class="line">...toRefs(user)</span><br><span class="line">//由原先的Proxy对象向下展开,变为一个基本对象,在配合运算符展开,相当于</span><br><span class="line">===========</span><br><span class="line">name:name</span><br><span class="line">age:age</span><br><span class="line">//在使用时,无需指定user</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230523212749.png" alt="image-20230523212749227"></p><h3 id="readOnly-shallowReadOnly"><a href="#readOnly-shallowReadOnly" class="headerlink" title="readOnly || shallowReadOnly"></a>readOnly || shallowReadOnly</h3><blockquote><p>深只读 || 浅只读</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230523221016.png" alt="image-20230523221016632"></p><h3 id="toRaw-markRaw"><a href="#toRaw-markRaw" class="headerlink" title="toRaw || markRaw"></a>toRaw || markRaw</h3><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230523221939.png" alt="image-20230523221939292"></p><h3 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h3><blockquote><p>创建一个自定义的ref,并对其依赖项跟踪和更新触发进行显示控制</p></blockquote><p><strong>自定义防抖</strong></p><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230523225312.png" alt="image-20230523225312077"></p><h3 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide || inject"></a>provide || inject</h3><blockquote><p>父组件与后代组件提供数据</p></blockquote><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230523230215.png" alt="image-20230523230215757"></p><h3 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h3><h4 id="teleport"><a href="#teleport" class="headerlink" title="teleport"></a>teleport</h4><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230523232237.png" alt="image-20230523232237372"></p><h3 id="suspense"><a href="#suspense" class="headerlink" title="suspense"></a>suspense</h3><blockquote><p>实现组件异步引入</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230523233253.png" alt="image-20230523233253172"></p><p>​    </p><h2 id="组合式-VS-选项式"><a href="#组合式-VS-选项式" class="headerlink" title="组合式 VS 选项式"></a>组合式 VS 选项式</h2><p>在vue2写法中,可以获取setup()中的数据</p><p>在vue3中,setup()读取不了,data(),methods中的数据,因为setup()在beforeCreate()之前执行</p><p><strong>当然,只是兼容,但不推荐v2,v3混写</strong></p><p>组合式api配合hook提取模块方法,使得项目结构更为清晰,易于维护</p><h2 id="Vue3相关调整"><a href="#Vue3相关调整" class="headerlink" title="Vue3相关调整"></a>Vue3相关调整</h2><ol><li>全局api<img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230523233558.png" alt="image-20230523233558682"></li><li>data属性应该定义为函数<code>data()&#123; return&#123;  name:&#39;zs&#39; &#125; &#125;</code></li><li>通过emits:[],判断子类上的事件是否为自定义事件</li><li>移除过滤器 </li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3路由</title>
      <link href="/2023/05/24/03vue3/"/>
      <url>/2023/05/24/03vue3/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue3路由"><a href="#Vue3路由" class="headerlink" title="Vue3路由"></a>Vue3路由</h2><blockquote><p>与vue2并无多大差别</p></blockquote><h3 id="创建路由模块"><a href="#创建路由模块" class="headerlink" title="创建路由模块"></a>创建路由模块</h3><ol><li>创建router.js</li><li>从vue-router中导入两个方法 {createRouter,createWebHashHistory}</li><li>创建路由对象 ,并配置路由信息,导出</li><li>在main.js中导入并使用app.use(router)挂载</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>导入的createRouter用来创建路由实例,createWebHashHistory函数指定history属性</p><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230522205523.png" alt="image-20230522205516158"></p><p>导入时,从原先在Vue.use使用app.use(router),全局挂载路由对象,其余配置几乎一样<img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230522205631.png" alt="image-20230522205631551"></p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><blockquote><p>redirect: 跳转到对应路径的路由页面</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; path: &#x27;/&#x27;, redirect: &#x27;/home&#x27; &#125;,</span><br></pre></td></tr></table></figure><h3 id="自定义激活类名"><a href="#自定义激活类名" class="headerlink" title="自定义激活类名"></a>自定义激活类名</h3><blockquote><p>显示对应的路由时,vue-link会生成默认的类名 —- router-link-active</p><p>当然可以在创建路由实例时,使用linkActiveClass指定</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230522210237.png" alt="image-20230522210237196"></p><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><blockquote><p>在路由组件中需要路由组件</p><p>在路由组件中使用children指定</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230522211920.png" alt="image-20230522211920325"></p><p>子类的path分为<strong>相对路径</strong>与<strong>绝对路径</strong></p><blockquote><p>绝对路径:开头带/ ,必须写全路径 ,例如: /home/son</p><p>相对路径:开头不带/ ,会自动补全  ,例如: son</p></blockquote><p>对应的嵌套的子路由router-link中的to要写为 <code>&lt;router-link to=&quot;/home/son&quot;&gt;</code></p><p>即为<strong>绝对路径</strong> </p><h4 id="嵌套路由重定向"><a href="#嵌套路由重定向" class="headerlink" title="嵌套路由重定向"></a>嵌套路由重定向</h4><ol><li>在根组件中<code>path:&#39;/home&#39; redirect:&#39;/home/son&#39;</code></li><li>在子组件中<code>path:&#39; &#39;   redirect:&#39;/home/son&#39;</code></li></ol><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><h3 id="路径参数"><a href="#路径参数" class="headerlink" title="路径参数"></a>路径参数</h3><blockquote><p>在跳转 路由页面时使用/xxx携带相关值</p><p>路由配置<code>path:&#39;/home/son/:id&#39;</code> 子路由使用<code>this.$route.params.xxx</code></p><p>开启props即为:<code>path:&#39;/home/son/:id&#39;  props:true</code> 对应子路由直接props接收</p><p><strong>可以嵌套,类似<code>home/son/xxx/xxx</code>,获取时$route.params会存在</strong></p></blockquote><p><strong>常规</strong><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230522213757.png" alt="image-20230522213757235" style="zoom:80%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230522213825.png" alt="image-20230522213825180" style="zoom: 150%;" /></p><p><strong>开启props:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230522214102.png" alt="image-20230522214102458"></p><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230522214120.png" alt="image-20230522214120794"></p><h3 id="query参数"><a href="#query参数" class="headerlink" title="query参数"></a>query参数</h3><blockquote><p>与上述路由使用时有所差别,上述路由需要 <code>xxx/:xxx</code>需要路由后绑定</p><p>query参数只需要 ?name=xxx&amp;age=114 原生path:’/home/son’无需改变</p><p>访问使用this.$route.query.xxx获取</p></blockquote><h3 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h3><p><strong>1. Path不同:</strong><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230522222035.png" alt="image-20230522222035892"></p><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230522222101.png" alt="image-20230522222101318"></p><p>2.取值不同:路径参数可以<strong>使用props</strong>方便获取值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$route.params.xxx</span><br><span class="line">props:[xxx]</span><br><span class="line">======================</span><br><span class="line">this.$route.query.xxx</span><br></pre></td></tr></table></figure><h3 id="对象写法"><a href="#对象写法" class="headerlink" title="对象写法"></a>对象写法</h3><p>在使用route-link中<strong>to</strong>使用<strong>v-bind</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123;</span><br><span class="line">                  name:&quot;xxx&quot;,//二选一</span><br><span class="line">                  path:&#x27;xx/xx&#x27;, //二选一</span><br><span class="line">                  params:&#123;</span><br><span class="line">                          //params的参数  </span><br><span class="line">                          &#125;,</span><br><span class="line">                  query:&#123;</span><br><span class="line">                         //查询参数   </span><br><span class="line">                         &#125;</span><br><span class="line">                  &#125;&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>在使用params时,如果使用name指定路径,不需要把路由中的地址写为<code>path:&#39;/home/:id&#39;</code></p><p>但是使用path指定路径,则需要<code>/:id</code>指定…..</p><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><blockquote><p>通过调用api实现导航的方式 ,在vue-router中使用this.$router.xxxx() </p></blockquote><ol><li>this.$router.replace(‘ hashPath ‘)—-不会增加浏览记录</li><li>push(‘Path’)—-跳转页面增加浏览记录</li><li>go(‘num’)—-前进或后退</li><li>back—go(-1)—后退一</li><li>forword—go(1)—前进一</li></ol><h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><blockquote><p>在配置路由时,指定name属性,当然name必须要有<strong>唯一性</strong></p><p>在使用时<router-link>的to需要 v-bind 写成对象,并指定name,省去path</p></blockquote><h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><blockquote><p>控制路由的访问权限</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230522225937.png" alt="image-20230522225937389"></p><h3 id="全局前置路由导航守卫"><a href="#全局前置路由导航守卫" class="headerlink" title="全局前置路由导航守卫"></a>全局前置路由导航守卫</h3><blockquote><p>在路由创建后使用router.beforeEach(回调函数)</p></blockquote><h4 id="beforEach"><a href="#beforEach" class="headerlink" title="beforEach"></a>beforEach</h4><p>在其中传递一个回调函数,会接受三个形参</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ( to ,from ,next )&#123;</span><br><span class="line">//to:代表去往的组件</span><br><span class="line">//from:来自哪个组件 </span><br><span class="line">//next:回调函数,表示放行next()</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>如果没用形参接收next,则默认全部放行</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230522231046.png" alt="image-20230522231046604"></p><p>组件中的内容<img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230522230800.png" alt="image-20230522230800158"></p><h4 id="next三种使用"><a href="#next三种使用" class="headerlink" title="next三种使用"></a>next三种使用</h4><ol><li>直接放行next()</li><li>强制停留当前页面next(false)</li><li>强制跳转其他页面next(‘/login’)</li></ol><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230522231352.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3的生命周期</title>
      <link href="/2023/05/24/02vue3/"/>
      <url>/2023/05/24/02vue3/</url>
      
        <content type="html"><![CDATA[<h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230521150423.png" alt="image-20230521150340630"></p><p><img src="https://cn.vuejs.org/assets/lifecycle.16e4c08e.png" alt="vue" style="zoom: 80%;" /></p><h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3><blockquote><p>组件在内存中创建完毕</p></blockquote><h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted:"></a>mounted:</h3><blockquote><p>组件被渲染到了页面上</p></blockquote><h3 id="updated"><a href="#updated" class="headerlink" title="updated:"></a>updated:</h3><blockquote><p>组件被重新渲染完毕</p></blockquote><h3 id="unmounted"><a href="#unmounted" class="headerlink" title="unmounted:"></a>unmounted:</h3><blockquote><p>组件被销毁了</p></blockquote><h3 id="全部周期函数"><a href="#全部周期函数" class="headerlink" title="全部周期函数"></a>全部周期函数</h3><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230521151840.png" alt="image-20230521151840300"></p><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><h3 id="父向子"><a href="#父向子" class="headerlink" title="父向子"></a>父向子</h3><blockquote><p>父组件使用 v-bind或直接通过props传递数据</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Son :data1=&quot;114&quot; data2=&quot;514&quot;&gt;&lt;/Son&gt;</span><br></pre></td></tr></table></figure><h3 id="子向父"><a href="#子向父" class="headerlink" title="子向父"></a>子向父</h3><blockquote><p>通过emits声明事件,$emit触发事件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emits:[&#x27;change&#x27;],</span><br><span class="line">methods:&#123;</span><br><span class="line">add()&#123;</span><br><span class="line">//...</span><br><span class="line">this.$emit(&#x27;change&#x27;,number);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------</span><br><span class="line">&lt;Son @change=&quot;getChange&quot;&gt;&lt;/Son&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export  default&#123;</span><br><span class="line">    method:&#123;</span><br><span class="line">        getChange(val)&#123;</span><br><span class="line">            console.log(val); //自定义数据处理</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="父子数据之间数据双向同步"><a href="#父子数据之间数据双向同步" class="headerlink" title="父子数据之间数据双向同步"></a>父子数据之间数据双向同步</h4><p><strong>父向子:</strong> 直接v-bind,通过props获取数据</p><p><strong>子向父:</strong>较为复杂</p><blockquote><ol><li><p>子组件定义emit:[‘update: ParmName’]</p></li><li><p>定义$emit(‘update: ParmName’,  ParmName)</p></li><li><p>父组件使用v-model:ParamName=”自己的数据”</p></li></ol></blockquote><p><strong>注意:</strong>   其中的ParamName只要与v-model的一样,不一定要与参数的变量名一样</p><h3 id="兄弟组件传数据"><a href="#兄弟组件传数据" class="headerlink" title="兄弟组件传数据"></a>兄弟组件传数据</h3><blockquote><p>使用EventBus,可以借助第三方的包<strong>mitt</strong>来创建eventBus对象</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230521161133.png" alt="image-20230521161133609"></p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230521163038.png" alt="image-20230521163038011"></p><p>在vue3中移除了事件总线,在vue2中的 vue.$emit和vue.$on已经不能使用,所以导入<strong>mitt</strong>作为事件总线 </p><h3 id="父向孙子组件"><a href="#父向孙子组件" class="headerlink" title="父向孙子组件"></a>父向孙子组件</h3><blockquote><p>使用provide(){ return { } },孙子组件使用inject获取值</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  provide() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      data: 404</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">==========</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;MySon&#x27;,</span><br><span class="line">  inject: [&#x27;data&#x27;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>provide类似于data的写法,inject写法类似于props的数组形式</p><h4 id="响应式获取"><a href="#响应式获取" class="headerlink" title="响应式获取"></a>响应式获取</h4><p>provide()传递的是<strong>非响应</strong>的数据(只会更新一次),要想保证父组件变化 ,inject获取实时的值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; computed &#125; from &#x27;vue&#x27;</span><br><span class="line">....</span><br><span class="line">provide() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      data: computed(() =&gt; this.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="孙子向父组件"><a href="#孙子向父组件" class="headerlink" title="孙子向父组件"></a>孙子向父组件</h3><blockquote><p>与子向父一样,使用this.$emit发送数据</p></blockquote><h3 id="VueX"><a href="#VueX" class="headerlink" title="VueX"></a>VueX</h3><blockquote><p>终极解决方案,让任意组件之间数据通信</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230521194722.png" alt="image-20230521194613576"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230521194844.png" alt="image-20230521194844255"></p><h2 id="全局挂载"><a href="#全局挂载" class="headerlink" title="全局挂载"></a>全局挂载</h2><h3 id="全局配置axios"><a href="#全局配置axios" class="headerlink" title="全局配置axios"></a>全局配置axios</h3><blockquote><p>在main.js入口处,通过app.config.globalProperties挂载axios</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line">const app = createApp(App)</span><br><span class="line"></span><br><span class="line">axios.defaults.baseURL = &#x27;&#x27;</span><br><span class="line">app.config.globalProperties.$http = axios</span><br><span class="line"></span><br><span class="line">app.mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure><p>使用时this.$http.get(…)</p><h3 id="全局自定义指令"><a href="#全局自定义指令" class="headerlink" title="全局自定义指令"></a>全局自定义指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.directive(&#x27;color&#x27;,&#123;</span><br><span class="line">mounted(el)&#123; // 带有v-color组件的DOM元素</span><br><span class="line">el.style.color=&#x27;red&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>vue2与vue3的属性名有所区别:</strong></p><p><img src="C:\Users\Acr.02\AppData\Roaming\Typora\typora-user-images\image-20230521231412809.png" alt="image-20230521231412809"></p><h4 id="绑定时获取传入值"><a href="#绑定时获取传入值" class="headerlink" title="绑定时获取传入值"></a>绑定时获取传入值</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v-color=&quot; &#x27;red&#x27; &quot;</span><br><span class="line">===============</span><br><span class="line">app.directive(&#x27;color&#x27;,&#123;</span><br><span class="line">mounted(el,binding)&#123; // 带有v-color组件的DOM元素,binding为传入的值对象</span><br><span class="line">el.style.color=binding,value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识vue3</title>
      <link href="/2023/05/24/01vue3/"/>
      <url>/2023/05/24/01vue3/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-Vite-快速构建项目"><a href="#使用-Vite-快速构建项目" class="headerlink" title="使用 Vite 快速构建项目"></a>使用 Vite 快速构建项目</h2><p><strong>初始化:</strong></p><blockquote><p>npm init vite-app 文件夹名字</p><p>cd 文件夹名字</p><p>npm install</p><p>npm run dev</p></blockquote><h2 id="Vue2-与-Vue3-的区别"><a href="#Vue2-与-Vue3-的区别" class="headerlink" title="Vue2 与 Vue3 的区别"></a>Vue2 与 Vue3 的区别</h2><h3 id="1-挂载-App"><a href="#1-挂载-App" class="headerlink" title="1. 挂载 App"></a>1. 挂载 App</h3><p>从原来的 new Vue 到现在的按需引入,减少了引入数量,加快了项目构建</p><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520214009.png" alt="image-20230520214009179"></p><h3 id="2-template-中的根节点"><a href="#2-template-中的根节点" class="headerlink" title="2. template 中的根节点"></a>2. template 中的根节点</h3><p>vue2 中只支持一个根节点,但是 vue3 支持多个根节点</p><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520214819.png" alt="image-20230520214819062"></p><h3 id="script-节点"><a href="#script-节点" class="headerlink" title="script 节点"></a>script 节点</h3><p>向下兼容,支持 vue2 中 data,method 的写法</p><h3 id="全局注册组件"><a href="#全局注册组件" class="headerlink" title="全局注册组件"></a>全局注册组件</h3><p>在 main.js 中</p><p>vue2</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue.component(&#x27;name1&#x27;,VC1) Vue.component(&#x27;name2&#x27;,VC2) new Vue(&#123; el:&#x27;#app&#x27;, render:h-&gt;h(app) &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cconst app=createApp(app) app.component(&#x27;name1&#x27;,VC1) app.component(&#x27;name2&#x27;,VC2)</span><br></pre></td></tr></table></figure><p><strong>注册时的 name,可以使用</strong>:</p><ol><li>短横线命名法</li><li>大驼峰命名法 (推荐)</li></ol><p>而且其中大驼峰可以转化为短横线命名法</p><p><strong><code>app.component(Movie.name,Movie)</code>,如果再创建 VC 实例时,添加了 name 属性,直接当作对象调用</strong></p><h4 id="scoped"><a href="#scoped" class="headerlink" title="scoped"></a>scoped</h4><p>css 的样式范围生效,当父组件希望子组件也生效,使用 <code>:deep()</code> 修饰,深度选择器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:deep(.title)&#123; color:red; &#125;</span><br></pre></td></tr></table></figure><h3 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h3><blockquote><p>自定义属性,父组件通过 props 传递数值,子类没有的被忽略</p></blockquote><p><code>&lt;MyCom data1=&quot;1000&quot; :data2=&quot;1000&quot;&gt;</code></p><p><strong>注意:</strong> data1 没使用 v-bind,传递的直接为字符串,但是 data2 使用了 v-bind,所以解析为数字 1000</p><h4 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h4><ol><li>数组模式 <code>props;[&#39;data1&#39;,&#39;data2&#39;]</code></li><li>对象模式,可以进一步约束对象的性质,默认值…</li></ol><h5 id="区别"><a href="#区别" class="headerlink" title="区别 :"></a>区别 :</h5><p><strong>vue2</strong>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">props:&#123; data1:&#123; type:Nuumber, required: rue &#125; &#125;</span><br></pre></td></tr></table></figure><p><strong>vue3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">props:&#123; data1: Number, //可以简写了,当然,多个属性还是对象写法 data2: [Number,String] //表示可以传两种参数 &#125;</span><br></pre></td></tr></table></figure><h5 id="validator"><a href="#validator" class="headerlink" title="validator"></a>validator</h5><blockquote><p>自定义 props 属性的验证函数,返回值为 Boolean 类型</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230521090524.png" alt="image-20230521090516972"></p><h3 id="Commputed-计算属性"><a href="#Commputed-计算属性" class="headerlink" title="Commputed(计算属性)"></a>Commputed(计算属性)</h3><blockquote><p>监听组件的变量,并作出相应处理,函数返回值保存在函数名中,可直接调用</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230521091202.png" alt="image-20230521091202839"></p><p>计算属性侧重于得到一个<strong>计算的结果</strong>,因此 计算属性必须要有<strong>return 返回值</strong></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230521091456.png" alt="image-20230521091455934"></p><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><blockquote><p>子向父传值</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230521093622.png" alt="image-20230521093622162"></p><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><ol><li>子组件定义 emits:[‘xxx’]数组,表明自定义事件,使用 this.$emit 触发</li><li>父组件通过 v-on(@)监听事件触发</li></ol><p><strong>区别:</strong>多了在 emits 数组中声明(不写也可以)</p><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230521094149.png" alt="image-20230521094149299"></p><h3 id="组件上同步数据"><a href="#组件上同步数据" class="headerlink" title="组件上同步数据"></a>组件上同步数据</h3><blockquote><p>分为 父向子:v-bind | 子向父:v-model…</p></blockquote><p><strong>父向子:</strong> v-bind</p><p><strong>子向父:</strong> 父组件 v-model,子组件 emits:[‘update: number’],再定义方法使用 this.$emit(‘update: number’,值),会同步修改父组件的值</p><p><strong>优点:</strong>简化了父组件定义函数,只需要子组件定义$emit,emits</p><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230521102230.png" alt="image-20230521102230088"></p><h3 id="watch-监听器"><a href="#watch-监听器" class="headerlink" title="watch 监听器"></a>watch 监听器</h3><blockquote><p>监听数据变化,并进行相应处理</p></blockquote><p><strong>简易写法:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watch:&#123; name(newVal,oldVal)&#123; //数据处理... &#125; &#125;</span><br></pre></td></tr></table></figure><p><strong>对象写法:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watch: &#123; name:&#123; handle(newval,oldval)&#123; &#125; , immediate:true //初始化时执行,否则只在改变时执行 &#125; &#125;</span><br></pre></td></tr></table></figure><h4 id="immediate"><a href="#immediate" class="headerlink" title="immediate"></a>immediate</h4><blockquote><p>监听的数据,是否在初始化时监听</p></blockquote><h4 id="deep"><a href="#deep" class="headerlink" title="deep"></a>deep</h4><blockquote><p>如果 watch 监听的是一个 对象,开启后会监听内部成员的变化,只要有任何一个值改变,就执行</p><p>handler 函数.</p></blockquote><h4 id="只监听对象的指定属性"><a href="#只监听对象的指定属性" class="headerlink" title="只监听对象的指定属性"></a>只监听对象的指定属性</h4><blockquote><p>对于 deep 监听,一个属性改变,就会执行 handler,但可能不是所期望的属性,所以指定属性监听</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user:&#123;name:&quot;&quot;,password=&quot;&quot;&#125; ======= watch:&#123; &quot;user.name&quot;:&#123; handler(new,old)&#123; &#125;, immediate:true &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="计算属性-VS-监听属性"><a href="#计算属性-VS-监听属性" class="headerlink" title="计算属性 VS 监听属性"></a>计算属性 VS 监听属性</h3><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230521145931.png" alt="image-20230521145931771"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6三种导出</title>
      <link href="/2023/05/24/es6/"/>
      <url>/2023/05/24/es6/</url>
      
        <content type="html"><![CDATA[<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="三种导出"><a href="#三种导出" class="headerlink" title="三种导出"></a>三种导出</h3><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520165515.png" alt="image-20230520164142280"></p><h4 id="1-默认导出"><a href="#1-默认导出" class="headerlink" title="1.默认导出"></a>1.默认导出</h4><p><strong>导出</strong>: <code>export defalut 成员</code> 每个模块只能导出 <strong>一次</strong></p><p><strong>导入:</strong> <code>import Name from  &#39;PathName&#39;</code>,可以使用任何 Name,只要符合规范</p><h4 id="2-按需导出"><a href="#2-按需导出" class="headerlink" title="2.按需导出"></a>2.按需导出</h4><p><strong>导出:</strong><code>export 导出的成员</code>,每个模块可以<strong>多次</strong></p><p><strong>导入:</strong><code>import &#123;相同的名字&#125; from &#39;pathName&#39;</code>,表示导出的成员,<strong>名称必须一致</strong></p><h4 id="两者配合"><a href="#两者配合" class="headerlink" title="两者配合"></a>两者配合</h4><p><code>import A,&#123;a,b&#125; from &#39;pathName&#39;</code></p><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520165823.png" alt="image-20230520165823847"></p><h4 id="3-直接导入并执行模块中的代码"><a href="#3-直接导入并执行模块中的代码" class="headerlink" title="3.直接导入并执行模块中的代码"></a>3.直接导入并执行模块中的代码</h4><p>模块中只是相关方法,只想执行一次,直接<code>import &#39;pathName&#39;</code>,代表只执行代码</p><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520170241.png" alt="image-20230520170241206"></p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p><strong>回调地狱:</strong>多层回调函数的相互嵌套</p><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520170914.png" alt="image-20230520170914653"></p><h4 id="使用-then-fs-对象-then-链式调用"><a href="#使用-then-fs-对象-then-链式调用" class="headerlink" title="使用 then-fs 对象 then()链式调用"></a>使用 then-fs 对象 then()链式调用</h4><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520201559.png" alt="image-20230520201559502"></p><h4 id="catch-捕获错误"><a href="#catch-捕获错误" class="headerlink" title="catch()捕获错误"></a>catch()捕获错误</h4><p>类似 java 的 try..catch()用于捕获错误</p><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h4><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520202027.png" alt="image-20230520202027076"></p><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h4><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520202106.png" alt="image-20230520202106887"></p><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520203043.png" alt="image-20230520203043774"></p><p>如果某个函数的返回值为 Promise 实例,则可以使用 await 获取其中的值,使用了 await,其方法必须要用 async 修饰</p><p><strong>注意事项</strong><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520203444.png" alt="image-20230520203444540"></p><h2 id="EventLoop-事件循环"><a href="#EventLoop-事件循环" class="headerlink" title="EventLoop(事件循环)"></a>EventLoop(事件循环)</h2><p>js 是一门<strong><em>单线程</em></strong>的语言,如果前一个任务耗时,则后续任务不会被执行</p><h3 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h3><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520203722.png" alt="image-20230520203722327"></p><h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520203757.png" alt="image-20230520203757561"></p><h3 id="JS-中同步与异步的执行顺序"><a href="#JS-中同步与异步的执行顺序" class="headerlink" title="JS 中同步与异步的执行顺序"></a>JS 中同步与异步的执行顺序</h3><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520204048.png" alt="image-20230520204048610"></p><ol><li>同步任务 js 直接执行并相应处理.遇到异步任务给宿主环境</li><li>已经<strong>完成的异步任务<em>对应的回调函数</em></strong>会放入任务队列,等待主线程同步任务执行完毕,再从任务队列中执行回调</li><li>直到任务队列为空</li></ol><h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><blockquote><p>对于异步任务的进一步划分</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520205636.png" alt="image-20230520205636483"></p><h4 id="宏任务与微任务的执行顺序"><a href="#宏任务与微任务的执行顺序" class="headerlink" title="宏任务与微任务的执行顺序"></a>宏任务与微任务的执行顺序</h4><p>顺序执行,宏任务执行结束,查看是否具有微任务并执行,再去执行下一个宏任务<img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520205853.png" alt="image-20230520205853690"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue路由</title>
      <link href="/2023/05/20/vue%E8%B7%AF%E7%94%B1/"/>
      <url>/2023/05/20/vue%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="SPA-与路由"><a href="#SPA-与路由" class="headerlink" title="SPA 与路由"></a>SPA 与路由</h2><p><strong>SPA</strong>:单页 Web 应用（single page web application，SPA），就是只有一张 Web 页面的应用，是加载单个 HTML 页面并在用户与应用程序交互时动态更新该页面的 Web 应用程序</p><p><strong>路由</strong>:通过 hash 地址获取,不会刷新页面,很适合使用,会留下浏览历史,很适合用于 SPA</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230519225054.png" alt="image-20230519225054612"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520090607.png" alt="image-20230520090600825"></p><h4 id="创建-router-模块"><a href="#创建-router-模块" class="headerlink" title="创建 router 模块"></a>创建 router 模块</h4><ol><li>src 下创建 router 文件夹,并创建 index.js</li><li>导入 Vue,VueRouter,并使用 Vue.use(VueRouter)挂载插件</li><li>创建 router 实例,配置 相关路由信息<img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520092600.png" alt="image-20230520092600125"></li><li>导出</li><li>main.js 中导入并挂载 router 实例</li></ol><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><ol><li>组件中使用<router-view>&lt;/router-view&gt;表示路由组件的展示位置</li><li><router-link to="/XXX" >&lt;/router-link&gt;表示点击展示哪个组件,无需#号</li></ol><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520093021.png" alt="image-20230520093021021"></p><h2 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h2><p>对于指定路由跳转到已定义的路由界面</p><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520093333.png" alt="image-20230520093333084"></p><hr><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p><u>多级路由的嵌套,使用<strong>children</strong>属性</u></p><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520093939.png" alt="image-20230520093939467"></p><h4 id="注意-子路由的-path-可以不加’-‘-如果加入要写全路径-gt-’-about-tab1’"><a href="#注意-子路由的-path-可以不加’-‘-如果加入要写全路径-gt-’-about-tab1’" class="headerlink" title="注意,子路由的 path 可以不加’/‘,如果加入要写全路径==&gt;’/about/tab1’"></a>注意,子路由的 path 可以不加’/‘,如果加入要写全路径==&gt;’/about/tab1’</h4><p><strong>相对路径与绝对路径的区别: 父: layout 子 : home || /user </strong></p><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520094431.png" alt="image-20230520094431915"></p><h3 id="默认子路由"><a href="#默认子路由" class="headerlink" title="默认子路由"></a>默认子路由</h3><p>子路由的 path 为’ ‘空时,当父路由未指定时,默认展示该路由,与<strong>redirct</strong>效果类似</p><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520094956.png" alt="image-20230520094956506"></p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>声明动态参数,可以匹配多个路由,并接收参数</p><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520103249.png" alt="image-20230520103249553"></p><p>1.</p><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520102709.png" alt="image-20230520102709801"></p><p>本体 Movie,可以使用$route获取相关参数,$router 可获取网址相关信息</p><ol><li>可以开启 props 传参,进一步简便书写<img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520103428.png" alt="image-20230520103428075"></li></ol><h4 id="查询参数"><a href="#查询参数" class="headerlink" title="查询参数"></a>查询参数</h4><p>使用<img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520104718.png" alt="image-20230520104718745"></p><p>作为 router-link 中 to 的参数时,Movie 路由实例可以使用$route.query 获取到相应的参数,props 不可使用.</p><p>这时 fullpath 与 path 具有区别</p><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><p>动态路由以及查询参数都是在用户点击 router-link 时在路由地址后面携带相关参数,让对应的 VueComponet 实例获取到不同的参数,从而做出不同的数据处理</p><h3 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h3><h4 id="声明式路由导航与编程式路由导航"><a href="#声明式路由导航与编程式路由导航" class="headerlink" title="声明式路由导航与编程式路由导航"></a>声明式路由导航与编程式路由导航</h4><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520105514.png" alt="image-20230520105514746"></p><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>这时候<strong><em>this.$router</em></strong>的作用就体现了</p><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520110401.png" alt="image-20230520110401443"></p><p>其中,$router.go()表示前进和后退</p><p>简化<img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520110649.png" alt="image-20230520110649072"></p><h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><p>防止用户未经过校验直接通过 浏览器地址访问指定页面</p><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520144832.png" alt="image-20230520143802279"></p><h4 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520144854.png" alt="image-20230520143852341"></p><p>其中函数会<strong>收到三个参数</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router.beforeEach(funtion(to,from ,next)&#123; ..... &#125;)</span><br></pre></td></tr></table></figure><p><strong>to</strong>:路由要访问的对象</p><p><strong>from</strong>:路由要来自的对象</p><p><strong>next</strong>:是一个 <strong>函数</strong>,使用 next()放行</p><h4 id="next-函数"><a href="#next-函数" class="headerlink" title="next()函数"></a>next()函数</h4><p>其中可以填入三种类型的参数</p><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520144855.png" alt="img"></p><h2 id="views-与-components"><a href="#views-与-components" class="headerlink" title="views 与 components"></a>views 与 components</h2><p>在写 vue 项目时,src 中有 views 以及 components 文件夹</p><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230520160532.png" alt="image-20230520160531963"></p><p><strong>views</strong>:放通过路由显示的组件</p><p><strong>components</strong>:不是通过路由显示的组件</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因为是组件化开发,使用路由可以避免刷新页面而获取不同的页面,</p><p><router-view>&lt;/router-view&gt;</p><p><router-link to="/xxx">&lt;/router-link&gt;</p><p><strong>1.传参数</strong></p><p>在有一些的情况下,跳转到指定的组件实例时,想传递参数,所以在 routes 配置中使用</p><ol><li>动态路由 path:’/movie/:id’,,可以使用$route.params 获取参数<br>简化: to:’/movie/1’ props:true,可以为组件开启 props 传参,进一步简化</li><li>查询参数: 在使用 to:’/movie?mid=1’,使用$route.query 获取参数</li></ol><p><strong>2.路由限制</strong></p><p>有些路由跳转希望做出限制,不能直接访问,使用<strong>前置路由守卫</strong></p><p><code>router.beforeEach(function( to,from,next ) &#123;&#125; )</code></p><p>做出相应判断</p><p><strong>3.路由嵌套</strong></p><p>一个路由页面中的可能还需要其他的路由页面,使用<strong><em>children</em></strong>进行嵌套</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue2知识</title>
      <link href="/2023/05/20/vue2%E6%8F%92%E6%A7%BD-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"/>
      <url>/2023/05/20/vue2%E6%8F%92%E6%A7%BD-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="ref-获取-dom-元素"><a href="#ref-获取-dom-元素" class="headerlink" title="ref 获取 dom 元素"></a>ref 获取 dom 元素</h2><p>首先在改组件中的标签中使用 ref=”name”</p><p>然后在实例化中使用 this.$refs={…}</p><p>所以 this.$refs.name=DOM 元素</p><hr><h3 id="一般使用"><a href="#一般使用" class="headerlink" title="一般使用"></a>一般使用</h3><ol><li>获取基本元素</li><li>获取子组件,直接调用其中的方法</li></ol><hr><h3 id="操作-DOM-注意"><a href="#操作-DOM-注意" class="headerlink" title="操作 DOM 注意"></a>操作 DOM 注意</h3><p>在操作 更改过的 DOM 时,因为 vue 的生命周期,使用 this.$nextTick( funtion( ){ } )</p><h2 id="Keep-alive"><a href="#Keep-alive" class="headerlink" title="Keep-alive"></a>Keep-alive</h2><p>在使用子组件时,不止可以用<Child></Child></p><p>也可以<component is='name'></component>指定要显示的数据</p><p><strong>使用的 name 为声明组件的 name</strong></p><p>更改显示时 ,会被销毁,所以使用 keep-alive 保证不会被回收</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Keep-alive&gt;</span><br><span class="line">    &lt;component is=&#x27;xxx&#x27;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/Keep-alive&gt;</span><br></pre></td></tr></table></figure><p>具有两个参数:</p><ol><li>include:<code>include=&quot;name1,name2&quot;</code></li><li>exclude:<code>exclude=&quot;name1,name2&quot;</code></li></ol><h2 id="slot-插槽"><a href="#slot-插槽" class="headerlink" title="slot 插槽"></a>slot 插槽</h2><p>父组件使用<Child>…..</Child>指定内容,子类使用 <slot></slot>,表示父类定义内容的存放点<strong>在 slot 中不指明 name=” xxx”,那么默认为 default,父类不指明 v-slot:name,默认为 default</strong></p><ol><li>v-slot 必须写在<template>或者 VueComponet 实例中</li><li>v-slot 可以简写为#name</li></ol><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>指定 slot,并 带有 name 作以区分</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;slot name=&quot;author&quot;&gt;&lt;/slot&gt;</span><br></pre></td></tr></table></figure><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;slot name=&quot;content&quot; data=&#123;name:&#x27;zs&#x27;,age:13&#125; data1=&#x27;hello world&#x27;&gt;&lt;/slot&gt;</span><br><span class="line">--------</span><br><span class="line">&lt;template #name=&#x27;scope&#x27;&gt;</span><br></pre></td></tr></table></figure><p>父类能接收到子类对应插槽中的所有数据,并封装为对象(感觉也是一种传参手段),一般使用<strong>scope</strong>作为名字,当然,其余名称也可以</p><p><strong>解构赋值 mydata=&gt;{data}</strong></p><h3 id="具名插槽与作用域插槽"><a href="#具名插槽与作用域插槽" class="headerlink" title="具名插槽与作用域插槽"></a>具名插槽与作用域插槽</h3><p><strong>在插槽中指了相关自定义信息就为作用域插槽</strong></p><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">directives:&#123; color:&#123;//使用时v-color bind(el,binding)&#123;//el代表绑定的DOM节点,binding使用时传递的数据,以及执行的函数 el.style.color=&#x27;red&#x27; &#125; &#125;, update(el,binding)&#123; //发生改变时的代码 &#125; &#125; &#125;</span><br></pre></td></tr></table></figure><p>当 binding 与 update 代码相同时</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">directives:&#123; color(el,binding)&#123; //代码段,包含bind函数以及update函数 &#125; &#125;</span><br></pre></td></tr></table></figure><h4 id="全局自定义指令"><a href="#全局自定义指令" class="headerlink" title="全局自定义指令"></a>全局自定义指令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue.directive(&#x27;color&#x27;,&#123; bind(el)&#123;&#125;,update(el)&#123;&#125; &#125;) ----- Vue.directive(&#x27;color&#x27;,funtion(el)&#123;&#125; )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230519223008.png" alt="全局简写"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跑路(暂缓)</title>
      <link href="/2023/05/19/%E8%B7%91%E8%B7%AF(%E6%9A%82%E7%BC%93)/"/>
      <url>/2023/05/19/%E8%B7%91%E8%B7%AF(%E6%9A%82%E7%BC%93)/</url>
      
        <content type="html"><![CDATA[<h2 id="我跑路了"><a href="#我跑路了" class="headerlink" title="我跑路了"></a>我跑路了</h2><p>之前魔改 butterfly 还觉得很有动力,但是在别人教程不适配,以及自己改不好的情况下<br>虽然花费了时间,但是与想象中的状态还是差别较大…</p><p>所以,干脆直接换了一个主题…</p><p>但这个也不会丢弃,毕竟自己逐渐搭建起来的,还是有点感情的(大嘘),绑个二级域名留着做纪念吧</p><p><img src="https://cdn.jsdelivr.net/gh/acxii/images@main/2023/05/20230517231037.jpg" alt="芝士图片"></p><h2 id="后悔了"><a href="#后悔了" class="headerlink" title="后悔了"></a>后悔了</h2><p>想跑路也不是那么容易,毕竟都要重新开始,这个就将就着用吧,反正就记录学习笔记,也不向外公开了</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 娱乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>告终</title>
      <link href="/2023/05/19/%E5%91%8A%E7%BB%88/"/>
      <url>/2023/05/19/%E5%91%8A%E7%BB%88/</url>
      
        <content type="html"><![CDATA[<h2 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h2><ol><li>历经几天,只能说搭建了一个雏形,好多功能以及效果都并未实现.<br>不过好在跑起来了,后续网站会不会使用也是个问题,当时萌生了想法就去做了.</li><li>也并不是完全没有收获,逐渐了解了通过控制台调整bug的流程,也了解了一些未接触的html语法(虽说本来就不太了解).</li><li>对于markdown的语法格式有了一定的了解,能写出基本的md结构</li><li>图床搭建,静态加速,域名解析…</li></ol><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>虽说大部分copy,但是不适配真的很烦人,自己还得根据控制台的报错,或者浏览器的样式自己一步一步改,<br>要是一开始选择一个容易配置的主题是否会轻松很多呢?虽说在这个主题上花费了几天的时间,但是效果还是不是很满意.</p><h2 id="总之"><a href="#总之" class="headerlink" title="总之"></a>总之</h2><p>跟着大佬的脚步一步步实现,但是有很多效果并不如意…<br>自己尝试修改但始终未果…<br>就这样结束吧…<br>也算是一段接触从未接触过领域的体验吧…</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 娱乐 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
